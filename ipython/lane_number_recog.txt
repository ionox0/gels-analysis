
# Import the modules
import cv2
from sklearn.externals import joblib
from sklearn import datasets
from skimage.feature import hog
from sklearn.svm import SVC
from sklearn import preprocessing
import numpy as np
from collections import Counter


import keras
from keras import applications
from keras.models import Sequential
from keras.datasets import mnist
from keras.layers import Dense, Dropout, Flatten, Activation, BatchNormalization
from keras.layers import Conv2D, MaxPooling2D
from keras import backend as K
from keras.utils.np_utils import to_categorical

from keras.applications.vgg16 import preprocess_input
from keras.preprocessing import image
from keras.utils import to_categorical

from sklearn.cross_validation import train_test_split
from sklearn.linear_model import LogisticRegression, LogisticRegressionCV


from matplotlib import pyplot as plt

# Load the dataset
dataset = datasets.fetch_mldata("MNIST Original")

# Extract the features and labels
features = np.array(dataset.data, 'int16')
labels = np.array(dataset.target, 'int')

# Extract the hog features
list_hog_fd = []
for feature in features:
    fd = hog(feature.reshape((28, 28)), orientations=9, pixels_per_cell=(14, 14), cells_per_block=(1, 1), visualise=False)
    list_hog_fd.append(fd)
hog_features = np.array(list_hog_fd, 'float64')

# Normalize the features
pp = preprocessing.StandardScaler().fit(hog_features)
hog_features = pp.transform(hog_features)
print ("Count of digits in dataset", Counter(labels))

clf = SVC(kernel='rbf')
clf.fit(hog_features, labels)

# Save the classifier
joblib.dump((clf, pp), "digits_cls.pkl", compress=3)

def get_model():
    model = Sequential()

    model.add(Conv2D(32, (3,3), input_shape=(28,28,1), padding='same'))
    model.add(BatchNormalization())
    model.add(Activation('relu'))
    model.add(Conv2D(32, (3, 3)))
    model.add(BatchNormalization())
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.25))

    model.add(Conv2D(64, (3, 3), padding='same'))
    model.add(BatchNormalization())
    model.add(Activation('relu'))
    model.add(Conv2D(64, (3, 3)))
    model.add(BatchNormalization())
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.25))

    model.add(Flatten())
    model.add(Dense(512))
    model.add(Activation('relu'))
    model.add(Dropout(0.5))
    model.add(Dense(10))
    model.add(Activation('softmax'))

    model.compile(loss=keras.losses.categorical_crossentropy,
                  optimizer=keras.optimizers.Adadelta(),
                  metrics=['accuracy'])
    return model



batch_size = 128
num_classes = 10
epochs = 12

model = get_model()

# Load the dataset
dataset = datasets.fetch_mldata("MNIST Original")

# Extract the features and labels
features = np.expand_dims(features.reshape(70000,28,28), axis=3)
labels = to_categorical(np.array(dataset.target, 'int'))

history_bn = model.fit(features, labels,
      batch_size=100,
      epochs=3)

# Save the classifier
model.save(filepath='./digits_cnn')

%matplotlib auto
# clf, pp = joblib.load("digits_cls.pkl")

imgs = [1,6,7,12,21,22,41,42,51,52,56,83,84,89,90,96,97,106,123,131,136,152,153,156,157]

for i in [131]:
    im = cv2.imread('../data/gels_nov_2016/Im{} - p. {}.png'.format(i, i))
    
    # Convert to grayscale and apply Gaussian filtering
    im_gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)
    im_gray = cv2.GaussianBlur(im_gray, (5, 5), 0)

    # Threshold the image
    ret, im_th = cv2.threshold(im_gray, 90, 255, cv2.THRESH_BINARY_INV)

    # Find contours in the image
    ctrs = cv2.findContours(im_th.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Get rectangles contains each contour
    rects = [cv2.boundingRect(ctr) for ctr in ctrs[1]]

    # For each rectangular region, calculate HOG features and predict
    # the digit using classifier.
    for rect in rects:
        # Draw the rectangles
#         cv2.rectangle(im, (rect[0], rect[1]), (rect[0] + rect[2], rect[1] + rect[3]), (0, 255, 0), 3)

        # Make the rectangular region around the digit
        leng = int(rect[3] * 1.6)
        pt1 = int(rect[1] + rect[3] // 2 - leng // 2)
        pt2 = int(rect[0] + rect[2] // 2 - leng // 2)
        roi = im_th[pt1:pt1+leng, pt2:pt2+leng]

        if roi.shape[0] == 0 or roi.shape[1] == 0: continue
        # Resize the image
        roi = cv2.resize(roi, (28, 28), interpolation=cv2.INTER_AREA)
        roi = cv2.dilate(roi, (3, 3))

        # Calculate the HOG features
        roi_hog_fd = hog(roi, orientations=9, pixels_per_cell=(14, 14), cells_per_block=(1, 1), visualise=False)
        roi_hog_fd = pp.transform(np.array([roi_hog_fd], 'float64'))
        
        roi_cnn = np.expand_dims(roi, axis=2)
        # Choose model here
        nbr = model.predict(np.array([roi_cnn])) # or roi_hog
        nbr = [np.argmax(nbr)]

        cv2.putText(im, str(int(nbr[0])), (rect[0], rect[1]), cv2.FONT_ITALIC, 1, (0, 255, 255), 3)
        # (img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) â†’ None

    plt.imshow(im)
    plt.show()

np.expand_dims(features.reshape(70000,28,28), axis=3).shape

model.summary()


